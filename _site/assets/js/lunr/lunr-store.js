var store = [{
        "title": "Исторические личности: Часть 1",
        "excerpt":"                                                  Отто фон Бисмарк       1 апреля 2015 года исполнилось 200 лет со дня рождения князя, государственного деятеля Германии, первого канцлера Германской империи Отто Эдуарда Леопольда фон Бисмарка.   Отто Эдуард Леопольд фон Бисмарк родился 1 апреля 1815 года в семье мелкопоместных дворян в поместье Шёнгаузен в Бранденбурге. Выходец из померанского юнкерства.   Изучал юриспруденцию сначала в университете в Геттингене, затем в университете в Берлине. В 1835 году получил диплом, в 1936 году проходил стажировку в Берлинском муниципальном суде.   В 1837-1838 годах работал чиновником в Ахене, затем в Потсдаме.   В 1838 году поступил на военную службу.   В 1839 году после смерти матери уволился со службы и занимался управлением семейными владениями в Померании.   После смерти отца в 1845 году семейная собственность была разделена, и Бисмарк получил поместья Шёнхаузен и Книпхоф в Померании.   В 1847-1848 годах — депутат первого и второго Соединенных ландтагов (парламент) Пруссии, во время революции 1848 года выступал за вооруженное подавление волнений.   Бисмарк стал известен благодаря своей консервативной позиции в ходе конституционной борьбы в Пруссии в 1848-1850 годах.   Противодействуя либералам, он способствовал созданию различных политических организаций и газет, включая “Новую прусскую газету” (Neue Preussische Zeitung, 1848). Один из организаторов прусской партии консерваторов.   Был депутатом нижней палаты парламента Пруссии в 1849 году и Эрфуртского парламента в 1850 году.   В 1851-1859 годах — представитель Пруссии в союзном сейме во Франкфурте-на-Майне.   С 1859 года по 1862 год Бисмарк был посланником Пруссии в России.   В марте — сентябре 1962 года — прусский посланник во Франции.   В сентябре 1862 года, во время конституционного конфликта между прусской королевской властью и либеральным большинством прусского ландтага, Бисмарк был призван королем Вильгельмом I на пост главы прусского правительства, а в октябре того же года стал министром-президентом и министром иностранных дел Пруссии. Он упорно отстаивал права короны и добился разрешения конфликта в ее пользу. В 1860-х годах осуществил военную реформу в стране, значительно усилил армию.   Под руководством Бисмарка было осуществлено объединение Германии путем “революции сверху” в результате трех победоносных войн Пруссии: в 1864 году совместно с Австрией против Дании, в 1866 году — против Австрии, в 1870-1871 годах — против Франции.   После образования Северо-Германского союза в 1867 году Бисмарк стал бундесканцлером. В провозглашенной 18 января 1871 года Германской империи он получил высший государственный пост имперского канцлера, став первым рейхсканцлером. В соответствии с конституцией 1871 года Бисмарк получил практически неограниченную власть. При этом он сохранил пост прусского премьер-министра и министра иностранных дел.   Бисмарк провел реформы германского права, системы управления и финансов. В 1872-1875 годах по инициативе и под давлением Бисмарка были приняты направленные против католической церкви законы о лишении духовенства права надзора за школами, о запрещении иезуитского ордена в Германии, об обязательном гражданском браке, об отмене статей конституции, предусматривавших автономию церкви и др. Эти мероприятия серьезно ограничили права католического духовенства. Попытки неподчинения вызывали репрессии.   В 1878 году Бисмарк провел через рейхстаг “исключительный закон” против социалистов, запрещавший деятельность социал-демократических организаций. Он беспощадно преследовал всякое проявление политической оппозиции, за что был прозван “железным канцлером”.   В 1881-1889 годах Бисмарк провел “социальные законы” (о страховании рабочих на случай болезни и на случай увечья, о пенсиях по старости и инвалидности), заложившие основы социального страхования рабочих. Вместе с тем он требовал ужесточения антирабочей политики и в течение 1880-х годов успешно добивался продления “исключительного закона”.   Свою внешнюю политику Бисмарк строил, исходя из ситуации, сложившейся в 1871 году после поражения Франции во франко-прусской войне и захвата Германией Эльзаса и Лотарингии, способствовал дипломатической изоляции Французской республики и стремился предотвратить образование любой коалиции, угрожавшей гегемонии Германии. Опасаясь конфликта с Россией и желая избежать войны на два фронта, Бисмарк поддержал создание русско-австро-германского соглашения (1873) “Союз трёх императоров”, а также заключил с Россией в 1887 году “договор перестраховки”. Вместе с тем в 1879 году по его инициативе заключён договор о союзе с Австро-Венгрией, а в 1882 году — Тройственный союз (Германии, Австро-Венгрии и Италии), направленный против Франции и России и положивший начало расколу Европы на две враждебные коалиции. Германская империя стала одним из лидеров международной политики. Отказ России от возобновления “договора перестраховки” в начале 1890 года явился серьезной неудачей канцлера, как и провал его плана превращения “исключительного закона” против социалистов в постоянно действующий. В январе 1890 года рейхстаг отказался возобновить его.   В марте 1890 года Бисмарк был уволен в отставку с поста рейхсканцлера и прусского премьер-министра в результате противоречий с новым императором Вильгельмом II и с военным командованием по вопросам внешней и колониальной политики и по рабочему вопросу. Он получил титул герцога Лауэнбургского, но от него отказался.   Последние восемь лет жизни Бисмарк провел в своем имении Фридрихсруэ. В 1891 году он был избран в рейхстаг от Ганновера, но так никогда и не занял там своего места, а двумя годами позже отказался выставить свою кандидатуру для переизбрания.   Отто фон Бисмарк является автором книги “Мысли и воспоминания” (Gedanken und Erinnerungen).   Он скончался 30 июля 1898 года в Гамбурге.   C 1847 года Бисмарк был женат на Йоханне фон Путткамер (умерла в 1894 году). У супругов было трое детей — дочь Мари (1848-1926) и два сына — Герберт (1849-1904) и Вильгельм (1852-1901).  ","categories": ["история"],
        "tags": ["history"],
        "url": "/%D0%B8%D1%81%D1%82%D0%BE%D1%80%D0%B8%D1%8F/bismark/",
        "teaser": null
      },{
        "title": "Необычный взгляд на редактирование текста. Часть I.",
        "excerpt":"Каждому из нас хоть раз в жизни приходилось иметь дело с обработкой текстовых документов. Дело казалось бы обыденное, открыл “офис” и вперёд, но некоторые до сих пор его не любят за то, что в нём куча ненужных для них вещей, а кто-то просто откровенно ими не умеет пользоваться. :)   Данный набор советов не претендует на то, чтобы полностью заменить вам ваш привычный текстовый редактор. Однако здесь я покажу вам как с помощью бесплатной и самое главное мощной утилиты сделать редактирование текста максимально быстро и эффективно.   Первое, что необходимо вам понимать, это то, что данная утилита довольно-таки сложна для начального уровня и требует некоторого понимая работы в командной строке (да, исходная программа, которая называется *vi, не имеет графического интерфейса). И хотя я буду показывать все примеры в командной строке, эти же примеры можно повторить в программе *Vim, которая как раз имеет данный графический интерфейс и немногим облегчит вам работу.   Вторым пунктом я хотел бы выделить именно тот факт, что я не хочу чтобы вы уходили от того же MS Office, (да и функционал в данной программе несколько иной), я лишь хочу показать то, как не имея лицензии на крупные программные продукты, а также надобности в тяжелом редактировании текста, использовать действительно полезный и главное очень эффективный продукт.   Итак, пустимся же в “весёлое приключение” по небольшой Вселенной Vi и Vim!   1. Это необходимо знать   Прежде чем приступить к написанию советов, хотелось бы остановиться на паре моментов, которые необходимо помнить.      Установка. Скачать и установить ПО вы можете по данной ссылке. Сложного в установке нет ничего, поэтому я верю в то, что вы справитесь. Я же буду использовать версию vi, которая есть в моем текстовом редакторе VS Code. Не пугайтесь! Всё, что я буду делать, вы сможете сделать и в Vim, установленный лично вами.   Примеры. Всё, что я буду выполнять, будет сопровождаться gif-анимационным файлом, в котором будут показаны все клавиши, задействованные в данном примере. Это очень удобно, как мне кажется, и вы сможете всегда вернуться и разобрать непонятный вам материал (хотя я очень верю, что такового не будет!). К сожалению, исходники самих примеров я выкладывать никуда не буду, поэтому вам придется на личных примерах разбираться как использовать ту или иную команду. Это поможет вам более тщательнее изучить весь материал и более подробно разобраться в интерфейсе и командах программы.   Слепая печать. Пожалуй, это единственное условие, которое необходимо выполнить прежде чем приступить к изучению Vim. Вам действительно будет тяжело разобраться в некоторых моментах без данного навыка, так как эфффективность работы в данной программе достигается за счёт ловкости рук!   2. Совет № 1. Повторение - мать учения   В повседной работе мы не замечаем как часто выполняем одни и те же операции: “скопировал - вставил”, “скопировал - вставил” и так десятки, а то и сотни раз всеразличных комбинаций клавиш. Если мы сможем как-то упростить выполнение одних и тех же операций, то сэкономим большое количество времени.   Редактор Vim позволяет отслеживать последние выполняемые операции и затем повторять их снова и снова, пока нам это будет необходимо. Однако, прежде чем приступить к редактированию какого-либо текста, необходимо упомянуть о двух основных режимах работы редактора Vim:     командный режим - обыкновенное состояние редактора, в котором выполняются все команды, за исключение главной функции редактора - редактирование текста. И это следует понимать, потому что очень часто возникают казусы, по которым люди не понимают различия в режимах и тем самым не могут найти решение в той или иной проблеме.   режим вставки - как понятно из названия, в данном режиме происходит набор необходимого нам текста.   При входе в программу вы попадаете в командный режим, а при нажатии клавиши i в режим вставки. Для того чтобы вернуться обратно в командный режим необходимо нажать клавишу Esc. Как видим ничего сложного нет!    Как узнать в каком режиме вы сейчас находитесь? Очень просто, в режиме вставки в левом нижнем углу будет надпись --ВСТАВКА-- или --INSERT-- (если у вас установлена англоязычная версия). При выходе в командный режим данная надпись исчезает.   Итак, для того чтобы повторить последнее изменение, в редакторе Vim существует команда “точка”. Данная команда одна из самых мощных и гибких в редакторе. При этом, под “последними изменениями” понимается изменение как над отдельными символами, целыми строками или даже файлами!      Краткая справка по командам.     Все команды выполняются в командном режиме!          h - шаг влево     j - шаг вниз     k - шаг вверх     l - шаг вправо     x - удаление символа под курсором     u - отменить последнее изменение     dd - удаление целой строки      Текущие команды будут использоваться в нашем первом примере. Вы увидите каким образом происходит перемещение по файлу, удаление символа, строки, а также повторение этих же действий с использованием магической команды “точка”.   В качестве примера я возьму небольшую программу и в ней проведу все наши эксперименты.                                                    Пример 1. Демонстрация применения команды точка       Обратите внимание на то, где расположен курсор и какие изменения происходят после выполнения определенной команды. А еще лучше, возьмите произвольный текст и поиграйтесь сами, выполняя различные команды.      Замечание!!! Для того чтобы выйти из данного редактора, особенно если вы выполняете упражнения в командной строке, необходимо выполнить одну из комбинаций клавиш:         :q! - выход из программы без сохранения     :wq - выход из программы c сохранением       Не забывайте, что команды выполняются в командном режиме!!!     Данная проблема очень популярна в интернете, так как начинающие пользователи не имеют представления как выйти из данного редактора. По этому поводу есть даже небольшая заметка в блоге stackoverflow. Там отмечено, что помощью по вопросу выхода из Vim воспользовалось более 1 млн. человек!!!   ","categories": ["editors"],
        "tags": ["vim"],
        "url": "/editors/vim_1/",
        "teaser": null
      },{
        "title": "RFC",
        "excerpt":"Список RFC, которые будут встречаться по ходу написания статей:           RFC 791 - Internet Protocol            RFC 792 - Internet Control Message Protocol            RFC 793 - Transmission Control Protocol            RFC 768 - User Datagram Protocol            RFC 826 - An Ethernet Address Resolution Protocol            RFC 925 - Multi-LAN Address Resolution            RFC 1027 - Using ARP to Implement Transparent Subnet Gateways            RFC 1624 - Computation of the Internet Checksum via Incremental Update            RFC 1700 - Assigned Numbers            RFC 3168 - The Addition of Explicit Congestion Notification (ECN) to IP      ","categories": ["networks"],
        "tags": ["rfc"],
        "url": "/networks/rfc/",
        "teaser": null
      },{
        "title": "Структура протокола IP",
        "excerpt":"Формат заголовка протокола IP состоит из определённого набора полей, которые описаны в RFC 791. Разбор данных полей важен для понимания процесса маршрутизации. Ниже я опишу данные поля и постараюсь показать их в реальности, используя Wireshark.         Структура протокола IP   Version - 4-битное поле, определяющее версию используемого протокола. В настоящее время используется две версии протокола - 4 (0100) версия и 6 (0110) версия.                                                    Version       Header Length - 4-битное поле, которое показывает какова длина IP-заголовка в 32-битных словах.    Заметка: Минимальный размер IP-заголовка - 20 байт (сумма всех полей заголовка при пустом поле Options). Так как максимально в поле из 4 бит можно записать значение 15 (1111), то максимальный размер IP-заголовка составляет 15 * 4 байта = 60 байт                                                    Header Length       Type of Service - 8-битное поле, может быть использовано для определения обработки пакета. В настоящее время данное поле переопределено как часть фреймворка Differentiated Services.   Данный фреймворк позволяет более гибко обрабатывать IP-пакеты. Фреймворк DiffServe определяет классы обслуживания (service classes) на маршрутизаторах, а затем позволяет производить сортировку согласно данным классам. Маршрутизатор может ставить в очередь и производить пересылку пакетов с различными уровнями приоритета в зависимости от их классификации. Каждая процедура постановки в очередь и пересылки называется PHB - Per-Hop Behaviour   В современном мире 6 бит поля Type of Service определено как поле DSCP - DiffServe Code Point. Используя эти 6 бит, произвольно либо в соответствии с предопределенными в архитектуре DiffServe классами обслуживания, администратор может определить до 64 классов обслуживания, которые затем могут быть отсортированы в PHB.   Оставшиеся 2 бита используется для поля ECN - Explicit Congestion Notification - явное уведомление о перегрузках (RFC 3168). Если маршрутизатор поддерживает данный параметр, то поле примет значение 11 в случае сигнализации о перегрузке.                                                    DiffServe and ECN       Total Length - 16-битное поле, определяет общую длину пакета, включая заголовок, в байтах. Вычитая длину заголовка можно получить размер данных. 16 бит может содержать максимальное значение в 65535, учитывая это получаем максимально возможное значение IP пакета - 65535 байт.                                                    Total Length       16-битное поле Identifier совместно с полями Flags и Fragment Offset используются для того чтобы показать был ли фрагментирован пакет или нет.   Пакет будет фрагментирован на более мелкие пакеты в случае когда его размер превышает Maximimum Transmition Unit (MTU) канальной среды через которую данный пакет будет передаваться.   Например, в случае когда MTU канальной среды равен 1500 байт и по ней передаётся пакет размером 5000 байт, то максимальный размер пакета может содержать только 1500 байт информации. Маршрутизатор должен маркировать каждый фрагмент с тем же значением в поле Identifier для того чтобы получающая сторона могла определить, что фрагменты относятся к одному и тому же пакету.    Заметка: фрагментированный пакет не собирается с каждой стороны канальной среды. Пакет остается фрагментированным до тех пор пока он не достигнет финальной точки назначения.   Flags - 3-битное поле, первый бит в котором не используется. Второй бит - бит DF (Don't Fragment). Когда данный бит установлен в 1, то маршрутизатор не может фрагментировать пакет.   Если пакет не может быть отправлен без фрагментации, маршрутизатор отбросит пакет и отправит источнику сообщение об ошибке пересылки. Данный функционал позволяет протестировать MTU в сети.   Рассмотрим простую схему между двумя маршрутизаторами:                                                    Схема №1       С помощью расширенной утилиты ping на маршрутизаторах Cisco можно найти максимальный MTU между устройствами.   Ниже представлен пример выполнения данной команды:   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 Router#  Router# ping Protocol [ip]:  Target IP address: 192.168.1.1 Repeat count [5]: 1 Datagram size [100]:  Timeout in seconds [2]:  Extended commands [n]: y Ingress ping [n]:  Source address or interface: 192.168.1.1 Type of service [0]:  Set DF bit in IP header? [no]: y Validate reply data? [no]:  Data pattern [0x0000ABCD]:  Loose, Strict, Record, Timestamp, Verbose[none]:  Sweep range of sizes [n]: y Sweep min size [36]: 1451 Sweep max size [18024]: 1550 Sweep interval [1]: 1 Type escape sequence to abort. Sending 100, [1451..1550]-byte ICMP Echos to 192.168.1.1, timeout is 2 seconds: Packet sent with a source address of 192.168.1.1  Packet sent with the DF bit set !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!.................... .............................. Success rate is 50 percent (50/100), round-trip min/avg/max = 1/1/1 ms Router#   Из вывода видно, что максимальный MTU равен 1500 байт. Существуют и другие способы как с помощью данной команды найти максимальный MTU между целой группой сетевых устройств.   Например, возьмем следующую схему *:                                                    Схема №2       В данной схеме на всех интерфейсах за исключением одного установлен MTU равный 1500 байт. Для того чтобы найти данный интерфейс мы также можем воспользоваться расширенной утилитой:   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 Router# ping Protocol [ip]:  Target IP address: 163.19.203.170 Repeat count [5]: 1 Datagram size [100]:  Timeout in seconds [2]:  Extended commands [n]: y Ingress ping [n]:  Source address or interface:  Type of service [0]:  Set DF bit in IP header? [no]: y Validate reply data? [no]:  Data pattern [0x0000ABCD]:  Loose, Strict, Record, Timestamp, Verbose[none]: r Number of hops [ 9 ]:  Loose, Strict, Record, Timestamp, Verbose[RV]:  Sweep range of sizes [n]: y Sweep min size [76]: 500 Sweep max size [18024]: 1500 Sweep interval [1]: 500 Type escape sequence to abort. Sending 3, [500..1500]-byte ICMP Echos to 163.19.203.170, timeout is 2 seconds: Packet sent with the DF bit set Packet has IP options:  Total option bytes= 39, padded length=40  Record route: &lt;*&gt;    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)  Reply to request 0 (3 ms) (size 500).  Received packet has options  Total option bytes= 40, padded length=40  Record route:    (192.168.172.50)    (163.19.203.180)    (163.19.203.170)    (163.19.203.170)    (192.168.172.60)    (192.168.172.50) &lt;*&gt;    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)  End of list  Reply to request 1 (3 ms) (size 1000).  Received packet has options  Total option bytes= 40, padded length=40  Record route:    (192.168.172.50)    (163.19.203.180)    (163.19.203.170)    (163.19.203.170)    (192.168.172.60)    (192.168.172.50) &lt;*&gt;    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)  End of list  Unreachable from 192.168.172.60, maximum MTU 1200 (size 1500).  Received packet has options  Total option bytes= 39, padded length=40  Record route: &lt;*&gt;    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)    (0.0.0.0)  Success rate is 66 percent (2/3), round-trip min/avg/max = 3/3/3 ms Router#   Из вывода видно, что максимальный MTU в данной схеме равен 1200 байт.   Третий бит в поле Flags - More Fragment. Когда маршрутизатор фрагментирует пакет, он записывает значение равное 1 в данный бит, за исключением последнего фрагмента. Этот бит необходим принимающей стороне для того чтобы определить где заканчивается фрагментированный пакет.   Fragment Offset - 13-битное поле, определяющее смещение от начала заголовка до начала фрагмента. Так как фрагменты не всегда могут приходить в правильном порядке, то данное поле позволяет принимающей стороне собрать фрагментированный пакет в правильном порядке.    Важно: в случае если в процессе передачи фрагментированного пакета теряется хотя бы один пакет, то весь пакет будет переслан заново. Таким образом, это может привести к непропорциональным задержкам в сети.                                                    Поля Identifier, Flags, Fragment Offset       Time to Live или просто TTL - 8-битное поле, в которое записывается некоторое число в момент создания пакета.                                                    Time to Live       По мере передачи пакета от одного маршрутизатора до другого, каждый из них будет уменьшать данное число. Если значение данного поля станет равным нулю, пакет будет отброшен и источнику пакета будет отправлено сообщение об ошибке пересылки. Данный механизм позволяет предотвратить бесконечное блуждание пакета по сети.   Современные маршрутизаторы в независимости от задержки уменьшают значение TTL на единицу. Рекомендуемое значение по умолчанию 64. Однако, встречаются и другие реализации в зависимости от операционной системы.   Некоторые утилиты для трасировки маршрута используют значение поля TTL. Пример выполнения трассировки приведён ниже:                                                    Traceroute       Protocol - 8-битное поле, определяющее номер вышестоящего протокола, которому предназначена передаваемая информация в пакете.                                                    Protocol       Ниже в таблице представлены одни из наиболее часто используемых протоколов, но данный список далеко не полный, каким может казаться на первый взгляд.                  Номер протокола       Название протокола                       1       Internet Control Message Protocol - ICMP                 2       Internet Group Management Protocol - IGMP                 4       IP in IP (encapsulation)                 6       Transmission Control Protocol - TCP                 17       User Datagram Protocol - UDP                 47       Generic Routing Encapsulation - GRE                 89       Open Shortest Path First - OSPF           Header Checksum - поле, определяющее ошибки в заголовке IP. Чексумма не вычисляется для содержимого IP пакета. Практически каждый вышестоящий протокол (будь то TCP, UDP, ICMP, etc.) имеет свои механизмы вычисления ошибок.   Данное поле представляет собой 16-битное значение, вычисляемое отправителем пакета. Принимающая сторона снова вычисляет данное значение и если значения сходятся, то считается, что чексумма не битая.                                                    Header Checksum        Важно: стоит помнить, что каждый маршрутизатор уменьшает значение поля TTL, поэтому значение чексуммы должно рассчитывается на каждом маршрутизаторе! RFC 1624 более подробно описывает процесс вычисления чексуммы в протоколе IP.   Source and Destination Addresses - 32-битный адреса источника и назначения пакета. Формат адресов представляет собой 4 десятичных числа от 0 до 255, разделенных точкой.                                                    Source and Destination IP Addresses       Options - поле переменной длины, как следует из описания используется для дополнительных опций.   Данное поле используется в основном для тестирования. Наиболее часто используемые опции:          Loose source routing - используется список IP-адресов, через которые должен пройти пакет, однако, на этом пути могут быть и другие адреса через которые не запрещено проходить     Strict source routing - в отличие от предыдущего варианта, пакет должен пройти через строго отведенные адреса. В случае если следующий адрес не находится в списке адресов, то возникает ошибка.     Record route - как и в случае трассировки маршрута, обеспечивает аналогичную функцию, за тем лишь исключением, что отображаются исходящие интерфейсы как на пути к месту назначения, так и на обратном пути. Данный механизм был показан ранее при выявлении максимального MTU в сети из нескольких устройств     Timestamp - отличается от Record route тем, что отслеживает не только где проходил пакет, но и когда.      Padding - используется для наполнения заголовка нулями (после поля Options), гарантируя, что граница конца заголовка проходит по 32 биту.   Для подробного анализа трафика можно скачать файл с дампом трафика, открыть его с помощью анализатора трафика Wireshark и пройтись по тем полям, которые были описаны выше в данной статье.   Также прикладываю файл топологий Eve-Ng, которые я использовал для тестирования прохождения трафика в данной статье (это лишь файл топологии, конфигурацию экспортировать нет возможности, т.к. у меня нет pro-версии Eve-Ng, но всегда можно обратиться ко мне напрямую и я поделюсь копипастом конфига. Образы устройств можно найти на просторах необъятного, а также использовать лицензионные образы устройств).      дамп трафика   топология eve-ng   P.S. вся информация представленная здесь используется исключительно в образовательных целях. Все совпадения с реальными объектами, адресами, именами и т.д. случайна и не несёт цели получить от этого выгоду или причинить кому-либо вред.  ","categories": ["networks"],
        "tags": ["protocols","ip"],
        "url": "/networks/ip_prot/",
        "teaser": null
      },{
        "title": "Структура и принцип работы протокола ARP",
        "excerpt":"Маршрутизаторы передают пакеты по какому-либо логическому пути, который состоит из определённого количества каналов передачи данных, “читая” и “взаимодействуя” с сетевыми адресами. Пакеты, инкапсулированные в кадры (фреймы), передаются через канальную среду. Фреймы содержат уникальные идентификаторы канальной среды (например, MAC-адреса) для определения адресата источника и назначения в канальной среде.   Устройствам в канальной среде необходим способ определения идентификаторов канальной среды соседей для того чтобы фреймы могли быть отправлены корректному адресату назначения. Одним из таких механизмов определения для протокола IP версии 4 является протокол ARP - Address Resolution Protocol, описанный в RFC 826.   1. Основы работы протокола ARP   На рисунке 1 изображён процесс работы протокола ARP                                                    Процесс работы протокола ARP       Устройство, которому необходимо узнать идентификатор канальной среды другого устройства, создает пакет ARP Request. Данный запрос содержит в себе IP-адрес устройства для которого необходимо узнать идентификатор канального среды (Target), а также данные канальной среды (в данном случае MAC-адрес) и IP-адрес устройства, которое данный запрос сформировало (Source).   Пакет ARP Request инкапсулируется в фрейм. В качестве MAC-адреса источника выступает сам источник, в качестве MAC-адреса назначения используется broadcast адрес (FFFF.FFFF.FFFF).   Вот как выглядит ARP Request если захватить его с помощью wireshark                                                    ARP Request       Подробно рассмотреть каждое поле запроса ARP можно скачав данный дамп   Broadcast адрес используется для того чтобы все узлы в канальной среде получили данный фрейм и обработали инкапсулированный внутри пакет. Все устройства, за исключением адресата назначения, поймут, что данный пакет не предназначается для них и попросту отбросят его. Устройство назначения обработает пакет и в ответ отправит ARP Reply адресату источника. Внутри ARP Reply будет содержаться как раз-таки MAC-адрес адресата назначения.   На следующем изображении можно увидеть как выглядит ARP Reply                                                    ARP Reply       Также скачав дамп с трафиком можно более подробно увидеть каждое поле пакета   2. Структура полей протокола ARP   Протокол ARP имеет следующие поля:                                                    Формат протокола ARP       Стоит напомнить, что формат протокола обычно показывается в разрезе 4 байт. Из-за этого часть информации из полей протокола может быть показана как часть следующих 4 байт (на примере Hardware и IP адресации).   Hardware Type - 16-битное поле, определяющее “тип канальной среды”. Наиболее часто используемые типы представлены в таблице ниже                  Номер       Тип среды                       1       Ethernet                 15       Frame Relay                 17       HDLC                 18       Fiber Channel                 20       Serial Link           Но основную часть всё же занимает именно Ethernet.                                                    Hardware Type       Protocol Type - 16-битное поле, определяющее протокол сетевого уровня, который отправитель связывает с идентификатором канала передачи данных. Для протокола IP версии 4 значение данного поля равно 0x0800                                                    Protocol Type       Hardware Address Length - 8-битное поле, определяющее длину идентификатора канальной среды в байтах. MAC-адреса имеет длину 48 бит или 6 байт.                                                    Hardware Address Length       Protocol Address Length - 8-битное поле, определяющее длину адреса сетевого уровня в байтах. IP-адреса имеет длину 32 бита или 4 байта.                                                    Protocol Address Length       Operation - 16-битное поле, которое определяет какой тип пакета ARP используется:           ARP Request - 1     ARP Reply - 2     Reverse ARP Request - 3     Reverse ARP Reply - 4     Inverse ARP Request - 8     Inverse ARP Reply - 9                                                       Opcode       Последние 20 байт приходятся на адресацию канальной среды и сетевого уровня источника и назначения запроса (MAC-адрес 6 байт * 2 + IP-адрес 4 байт * 2 = 20)                                                    MAC + IP адреса       3. Практика   Посмотрим небольшую практику на примере следующей схемы:                                                    Схема №1       Для того чтобы отследить пакеты arp на устройствах cisco можно воспользоваться утилитой debug. Для этого необходимо в привилегированном режиме выполнить команду debug arp   1 2 3 4 5 6 7 8 9 10 Router# debug arp ARP packet debugging is on Router# *Oct  4 18:48:11.317: IP ARP: rcvd req src 185.14.32.135 0050.0000.0200, dst 185.14.32.1 GigabitEthernet0/0 *Oct  4 18:48:11.317: IP ARP: creating entry for IP address: 185.14.32.135, hw: 0050.0000.0200 *Oct  4 18:48:11.317: IP ARP: sent rep src 185.14.32.1 5000.0003.0000,                  dst 185.14.32.135 0050.0000.0200 GigabitEthernet0/0 Router# undebug all All possible debugging has been turned off Router#    Важно: команда debug очень требовательна к ресурсам, следует аккуратно использовать её на производстве. При неаккуратном задании параметров можно потерять доступ к устройству из-за постоянного спама сообщений в консоль.   Для просмотра таблицы ARP на устройствах cisco можно выполнить команду show arp в привилегированном режиме. Для операционной системы Windows можно выполнить команду arp -a, а для Linux команда выглядит arp -vn. Примеры выполнения команд приведены ниже:                                                    Cisco ARP table                                                        Windows ARP table                                                        Linux ARP table       Стоит обратить внимание на колонку Age в выводе команды на маршрутизаторе. Данная колонка показывает через какое количество времени данная запись будет удалена из таблицы ARP. Это сделано для того чтобы предотвратить перегрузку таблицы ARP устаревшими записями.   По умолчанию устройства cisco хранятся информацию у себя в таблице ARP в течение 4 часов, это можно проверить командой show interface &lt;имя_интерфейса&gt; | include ARP   1 2 3 4 Router# show int gi0/0 | inc ARP   Encapsulation ARPA, loopback not set   ARP type: ARPA, ARP Timeout 04:00:00 Router#   Поведение по умолчанию можно изменить, выполнив следующий набор команд (настройка актуальна для отдельного интерфейса)   1 2 3 4 5 6 7 8 9 10 Router# conf t Enter configuration commands, one per line.  End with CNTL/Z. Router(config)# interface gi0/0 Router(config-if)# arp timeout 1800 Router(config-if)# end *Oct  4 20:56:43.122: %SYS-5-CONFIG_I: Configured from console by console Router# show int gi0/0 | inc ARP   Encapsulation ARPA, loopback not set   ARP type: ARPA, ARP Timeout 00:30:00 Router#   Для очистки ARP кэша можно выполнить команду   1 Router# clear arp-cache   В следующий раз я вкратце рассмотрю другие разновидности протокола ARP: Proxy ARP, Gratuitous ARP, Reverse ARP.   P.S. вся информация представленная здесь используется исключительно в образовательных целях. Все совпадения с реальными объектами, адресами, именами и т.д. случайна и не несёт цели получить от этого выгоду или причинить кому-либо вред.  ","categories": ["networks"],
        "tags": ["protocols","arp"],
        "url": "/networks/arp_prot/",
        "teaser": null
      },{
        "title": "Разновидности протокола ARP",
        "excerpt":"В предыдущей статье был рассмотрен протокол ARP, структура и принцип его работы. Сегодня я хочу показать несколько разновидностей данного протокола, которые также иногда используются в сетях.   Proxy ARP   Иногда его еще называют promiscuous ARP, данный протокол описан в RFC 925 и RFC 1027.   Proxy ARP - это метод с помощью которого маршрутизаторы могут сделать себя доступными для устройств.   Например, устройство с адресом 15.65.32.124/24 хочет отправить пакет на адрес 15.65.100.35/24, но на данном устройстве не настроен шлюз по умолчанию, поэтому устройство не знает как отправить на маршрутизатор пакет. В таком случае устройство генерирует ARP Request для адреса 15.65.100.35. Локальный маршрутизатор, получив данный запрос и зная как достичь сети 15.65.100.0, сгенерирует и отправит ответный пакет ARP Reply, в котором будет содержаться его собственный идентификатор канальной среды.   Таким образом, маршрутизатор заставит устройство поверить, что интерфейс маршрутизатора и есть интерфейс с адресом 15.65.100.35. Все пакеты, которые будут генерироваться для данного адреса будут отправляться на интерфейс маршрутизатора. Данный пример является скорее исключением, потому что в современном мире всё же принято назначать адрес шлюза на устройство, для того чтобы не делать дополнительных забот для сети.   Второй вариант использования Proxy ARP - несовпадение масок на интерфейсах шлюза и устройств. Допустим на маршрутизаторе есть два интерфейса. Каждому из интерфейсов назначены адреса с /28 маской. Пусть будет на первом интерфейсе адрес 160.1.74.1/28, а на другом 160.1.74.28/28. Данные адреса на интерфейсах располагаются в разных подсетях.   Клиентские устройства же сконфигурированы в той же сети 160.1.74.0, но с маской /24 и не имеют представления о существовании подсетей с /28 маской. Например, первый клиент имеет адрес 160.1.74.10/24, а второй клиент адрес 160.1.74.20/24.   Для того чтобы первый смог отправить информацию второму ему необходимо создать запрос ARP Request. Маршрутизатор, получив пакет, распознает, что адрес назначения с его точки зрения находится в другой подсети и как и в первом случае отправит ответный пакет ARP Reply, в котором будет содержаться собственный идентификатор канальной среды маршрутизатора.   Таким образом, Proxy ARP делает прозрачной топологию подсетей для клиентских устройств.   Gratuitous ARP   Устройство иногда может создавать запрос ARP со своим собственным IP-адресом в качестве адреса назначения. Такой запрос ARP называется Gratuitous ARP и может использоваться в следующих случаях:      Первый случай - использование для проверки дублирования адресов в сети. Устройство, которое отправит ARP Request со своим собственным адресом в качестве адресата назначения в запросе и в ответ получит ARP Reply от другого устройства, сможет узнать, что данный адрес является дубликатом в сети   Второй случай - использование для того чтобы объявить свой новый идентификатор канальной среды. Если устройство получает ARP Request для IPv4 адреса, который уже есть в кэше ARP, то кэш будет обновлен, используя новый идентификатор канального уровня отправителя   Третий случай - использование маршрутизаторами протокола Hot Standby Router Protocol (HSRP). В случае когда активный маршрутизатор теряет свою роль активного, резеврный маршрутизатор отправляет Gratuitous ARP для того чтобы обновить кэш ARP у устройств в той же подсети   По умолчанию Gratuitous ARP выключен на маршрутизаторах cisco. Для того чтобы отключить данное поведение, надо в режиме глобальной конфигурации ввести команду ip gratuitous-arps.   Подробно посмотреть GARP можно скачав данный дамп   Reverse ARP   Вместо сопоставления идентификатора канальной среды с заранее известным IP-адресом, Reverse ARP позволяет сопоставить IP-адрес с заранее известным идентификатором канальной среды.   Некоторые устройства после старта системы могут не знать свой IP-адрес. RARP может быть запрограммирован в программное обеспечение данных устройств, позволяя данному устройству выполнить ARP Request с идентификатором канальной среды самого устройства. Ответный RARP Reply будет содержать соответствующий IP-адрес.   RARP был значительный образом вытеснен протоколом DHCP (Dynamic Host Configuration Protocol) - расширением протокола Bootstrap (BootP), каждый из которых предоставляет куда больше информации нежели один IP-адрес.   Также более подробно посмотреть протокол RARP можно скачав этот дамп   Практика   Рассмотрим на практике второй вариант использования Proxy ARP. Возьмем схему и адресацию, указанную в описании метода использования Proxy ARP.                                                    Схема Proxy ARP       Выполнив все настройки адресации на интерфейсах клиентов и маршрутизатора, запустим ping между клиентами.   Первоначально в таблице ARP на маршрутизаторе не присутстовали никакие записи, кроме записей собственных интерфейсов:   1 2 3 4 5 Router# show arp Protocol  Address          Age (min)  Hardware Addr   Type   Interface Internet  160.1.74.1              -   5000.0003.0000  ARPA   GigabitEthernet0/0 Internet  160.1.74.28             -   5000.0003.0001  ARPA   GigabitEthernet0/1 Router#   После запуска ping на клиенте можно увидеть, что маршрутизатор отвечает на запрос клиента свой ответом, предварительно включив на маршрутизаторе debug arp   1 2 3 4 5 6 7 8 9 10 11 *Oct  5 21:33:42.486: IP ARP: rcvd req src 160.1.74.10 5000.0001.0000, dst 160.1.74.20 GigabitEthernet0/0 *Oct  5 21:33:42.487: IP ARP: creating entry for IP address: 160.1.74.10, hw: 5000.0001.0000 *Oct  5 21:33:42.487: IP ARP: sent rep src 160.1.74.20 5000.0003.0000,                  dst 160.1.74.10 5000.0001.0000 GigabitEthernet0/0 *Oct  5 21:33:42.489: IP ARP: creating incomplete entry for IP address: 160.1.74.20 interface GigabitEthernet0/1 *Oct  5 21:33:42.490: IP ARP: sent req src 160.1.74.28 5000.0003.0001,                  dst 160.1.74.20 0000.0000.0000 GigabitEthernet0/1 *Oct  5 21:33:42.491: IP ARP: rcvd rep src 160.1.74.20 0050.0000.0200, dst 160.1.74.28 GigabitEthernet0/1 *Oct  5 21:33:42.493: IP ARP: rcvd req src 160.1.74.20 0050.0000.0200, dst 160.1.74.10 GigabitEthernet0/1 *Oct  5 21:33:42.494: IP ARP: sent rep src 160.1.74.10 5000.0003.0001,                  dst 160.1.74.20 0050.0000.0200 GigabitEthernet0/1   Теперь на маршрутизаторе есть полная карта для всех устройств в сети   1 2 3 4 5 6 7 Router# show arp Protocol  Address          Age (min)  Hardware Addr   Type   Interface Internet  160.1.74.1              -   5000.0003.0000  ARPA   GigabitEthernet0/0 Internet  160.1.74.10             8   5000.0001.0000  ARPA   GigabitEthernet0/0 Internet  160.1.74.20            16   0050.0000.0200  ARPA   GigabitEthernet0/1 Internet  160.1.74.28             -   5000.0003.0001  ARPA   GigabitEthernet0/1 Router#   Однако для того чтобы понять, что в сети настроен Proxy ARP надо обратиться к клиенту и проверить таблицу ARP у него.                                                    Таблица ARP в Linux       В таблице можно заметить, что для двух разных IP-адресов идёт соответствие одинакового идентификатора канальной среды - MAC-адреса интерфейса Gi0/1 маршрутизатора. Это и есть признак того, что в сети работает Proxy ARP.   По умолчанию Proxy ARP включен на маршрутизаторах cisco. Для того чтобы отключить данное поведение, надо ввести команду no ip proxy-arp на интерфейсе маршрутизатора.   P.S. вся информация представленная здесь используется исключительно в образовательных целях. Все совпадения с реальными объектами, адресами, именами и т.д. случайна и не несёт цели получить от этого выгоду или причинить кому-либо вред.  ","categories": ["networks"],
        "tags": ["protocols","arp"],
        "url": "/networks/arp_types/",
        "teaser": null
      },{
        "title": "Структура протокола ICMP",
        "excerpt":"Internet Control Message Protocol или просто ICMP описан в RFC 792. Данный протокол определяет набор различных сообщений, целью которых является управление сетью.   ICMP сообщения могут классифицироваться как сообщения об ошибках, а также как сообщения типа “запрос - ответ”.    graph TD  C{ICMP}     C --&gt; D[Error message]     C --&gt; E[Query-Response]   Ниже представлен основной формат пакета ICMP                                                    Структура протокола ICMP       Пакеты ICMP определяются по их типу (Type), однако, большинство типов могут иметь более специфичные типы, они определяются по полю Code. RFC 1700 определяет все основные типы и коды для протокола ICMP.   В следующей таблице перечислены данные поля с их описанием    \t \t\t \t\t\tТип \t\t\tКод \t\t\tНазвание \t\t \t \t \t\t \t\t\t0 \t\t\t0 \t\t\tEcho Reply \t\t \t\t \t\t\t3 \t\t\t&nbsp; \t\t\tDESTINATION UNREACHABLE \t\t \t\t \t\t\t0 \t\t\tNetwork Unreachable \t\t \t\t \t\t\t1 \t\t\tHost Unreachable \t\t \t\t \t\t\t2 \t\t\tProtocol Unreachable \t\t \t\t \t\t\t3 \t\t\tPort Unreachable \t\t \t\t \t\t\t4 \t\t\tFragmentation Needed and Don't Fragment Flag Set \t\t \t\t \t\t\t5 \t\t\tSource Route Failed \t\t \t\t \t\t\t6 \t\t\tDestination Network Unknown \t\t \t\t \t\t\t7 \t\t\tDestination Host Unknown \t\t \t\t \t\t\t8 \t\t\tSource Host Isolated \t\t \t\t \t\t\t9 \t\t\tDestination Network Administratively Prohibited \t\t \t\t \t\t\t10 \t\t\tDestination Host Administratively Prohibited \t\t \t\t \t\t\t11 \t\t\tDestination Network Unreachable for Type of Service \t\t \t\t \t\t\t12 \t\t\tDestination Host Unreachable for Type of Service \t\t \t\t \t\t\t4 \t\t\t0 \t\t\tSOURCE QUENCH (deprecated) \t\t \t\t \t\t\t5 \t\t\t&nbsp; \t\t\tREDIRECT \t\t \t\t \t\t\t0 \t\t\tRedirect Datagram for the Network (or Subnet) \t\t \t\t \t\t\t1 \t\t\tRedirect Datagram for the Host \t\t \t\t \t\t\t2 \t\t\tRedirect Datagram for the Network and Type of Service \t\t \t\t \t\t\t3 \t\t\tRedirect Datagram for the Host and Type of Service \t\t \t\t \t\t\t6 \t\t\t0 \t\t\tALTERNATE HOST ADDRESS \t\t \t\t \t\t\t8 \t\t\t0 \t\t\tECHO \t\t \t\t \t\t\t9 \t\t\t0 \t\t\tROUTER ADVERTISEMENT \t\t \t\t \t\t\t10 \t\t\t0 \t\t\tROUTER SELECTION \t\t \t\t \t\t\t11 \t\t\t&nbsp; \t\t\tTIME EXCEEDED \t\t \t\t \t\t\t0 \t\t\tTime to Live Exceeded in Transmit \t\t \t\t \t\t\t1 \t\t\tFragment Reassembly Time Exceeded \t\t \t\t \t\t\t12 \t\t\t&nbsp; \t\t\tPARAMETER PROBLEM \t\t \t\t \t\t\t0 \t\t\tPointer Indicates the Error \t\t \t\t \t\t\t1 \t\t\tMissing a Required Option \t\t \t\t \t\t\t2 \t\t\tBad Length \t\t \t\t \t\t\t13 \t\t\t0 \t\t\tTIMESTAMP \t\t \t\t \t\t\t14 \t\t\t0 \t\t\tTIMESTAMP REPLY \t\t \t\t \t\t\t15 \t\t\t0 \t\t\tINFORMATION REQUEST (Obsolete) \t\t \t\t \t\t\t16 \t\t\t0 \t\t\tINFORMATION REPLY (Obsolete) \t\t \t\t \t\t\t17 \t\t\t0 \t\t\tADDRESS MASK REQUEST (Near-Obsolete) \t\t \t\t \t\t\t18 \t\t\t0 \t\t\tADDRESS MASK REPLY (Near-Obsolete) \t\t \t\t \t\t\t30 \t\t\t- \t\t\tTraceroute \t\t \t   Данную информацию не следует учить, как и другую представленную в статьях, главное научиться понимать что это и для чего используется, остальное приходит с опытом работы. Тем более, что вся представленная информация общедоступна каждому из нас бесплатно.   Одни из наиболее часто встречающихся примеров ICMP сообщений являются Echo и Reply. По ссылке можно скачать дамп, показывающий выполнение команды ping в сторону адреса 8.8.8.8. Ниже будут представлены вырезки Echo и Reply из данных дампов.                                                    ICMP Request                                                        ICMP Reply       Далеко не все типы пакетов ICMP можно встретить сегодня в современных сетях, но некоторые из них имеют важное значение для функционала маршрутизации, например, редирект - ICMP Type 5.   Данный тип используется маршрутизаторами для уведомления других устройств о том, что для данного адреса назначения в текущей канальной среде следует использовать другой маршрутизатор.   Предположим, что в одной канальной среде с конечным устройством есть два маршрутизатора Router-London и Router-Moscow. Маршрутизатор Router-Moscow является шлюзом по умолчанию для конечного устройства. Конечное устройство отправляет пакет на маршрутизатор Router-Moscow, в свою очередь маршрутизатор Router-Moscow имеет достижимость адреса на который отправил конечный хост через маршрутизатор Router-London.   Получается, что маршрутизатор Router-Moscow должен отправить пакет в тот же самый интерфейс на котором он получил изначальный пакет. Маршрутизатор Router-Moscow отправляет пакет маршрутизатору Router-London, а также отправляет сообщение ICMP Redirect конечному устройству, информируя его о том, что все следующие пакеты он должен отправлять непосредственно через маршрутизатор Router-London (имеется в виду только до сети, куда был отправлен первый пакет, все пакеты до других сетей отправляются также на шлюз по умолчанию)   Практика   Рассмотрим пример с ICMP Redirect на практике. Имеется простая схема с двумя маршрутизаторами в одной канальной среде                                                    Схема ICMP Redirect       Вся адресация представлена на схеме. В качестве простоты эксперимента рассмотрим ситуацию когда клиент будет отправлять пинг на адрес внешнего интерфейса маршрутизатора Router-London, маршрутизатор Router-Moscow является шлюзом для клиента.   На маршрутизаторе Router-Moscow дополнительно настроен статический маршрут до сети 172.17.0.0/24 через адрес внутреннего интерфейса маршрутизатора Router-London.   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 Router_Moscow# show ip route static Codes: L - local, C - connected, S - static, R - RIP, M - mobile, B - BGP        D - EIGRP, EX - EIGRP external, O - OSPF, IA - OSPF inter area         N1 - OSPF NSSA external type 1, N2 - OSPF NSSA external type 2        E1 - OSPF external type 1, E2 - OSPF external type 2        i - IS-IS, su - IS-IS summary, L1 - IS-IS level-1, L2 - IS-IS level-2        ia - IS-IS inter area, * - candidate default, U - per-user static route        o - ODR, P - periodic downloaded static route, H - NHRP, l - LISP        a - application route        + - replicated route, % - next hop override, p - overrides from PfR  Gateway of last resort is not set        172.17.0.0/24 is subnetted, 1 subnets S        172.17.0.0 [1/0] via 192.168.1.254 Router_Moscow#   Включив дебаг на маршрутизаторе Router-Moscow с помощью команды debug ip icmp, можно заметить как данный маршрутизатор отправляет сообщение ICMP Redirect клиенту.   1 2 3 4 5 Router_Moscow# debug ip icmp  ICMP packet debugging is on Router_Moscow# *Oct  9 11:46:43.504: ICMP: redirect sent to 192.168.1.100 for dest 172.17.0.254, use gw 192.168.1.254 Router_Moscow#   При этом первый пакет на клиенте потеряется из-за того, что маршрутизатор Router-London не будет знать куда отправлять ответ на первый ICMP Request клиента, т.к. его кэш ARP будет пуст и ему придется отправить ARP Request чтобы узнать MAC-адрес клиента.                                                    Потеря первого пакета при пинге клиента       Для того чтобы убедиться в правдивости моих слов предлагаю скачать дампы с двух интерфейсов маршрутизатора Router-London и Router-Moscow и посмотреть весь процесс самим.    Помните: так как все устройства находятся в общей широковещательной среде, то все пакеты отправленные на широковещательный адрес ffff.ffff.ffff будут видны в каждом из дампов.   Дамп с интерфейса gi0/0 маршрутизатора Router-Moscow Дамп с интерфейса gi0/0 маршрутизатора Router-London   По умолчанию редирект включен на устройствах cisco. Данное поведение можно отключить на интерфейсе, выполнив команду no ip redirects   P.S. вся информация представленная здесь используется исключительно в образовательных целях. Все совпадения с реальными объектами, адресами, именами и т.д. случайна и не несёт цели получить от этого выгоду или причинить кому-либо вред.  ","categories": ["networks"],
        "tags": ["protocols","icmp"],
        "url": "/networks/icmp_prot/",
        "teaser": null
      },{
        "title": "Структура протокола TCP",
        "excerpt":"Transmission Control Protocol или TCP описан в RFC 793, обеспечивает приложениям надежную службу, ориентированную на подключение.   Протокол TCP похож на телефонный звонок, в котором сначала устанавливается соединение, затем передаются данные, и в конце осуществляется отключение когда передача данных завершена.   TCP использует три основных механизма, описанных ниже:      Пакеты маркируются порядковыми номерами (sequence number). Это позволяет службе TCP с приёмной стороны восстановить корректную последовательность пакетов, прежде чем отправлять их конечному приложению.   Для обеспечения надежности TCP использует механизмы подтверждения, чексуммы и таймеров (acknowledment, checksum, timers). Получатель может уведомить отправителя о том, что какой-то пакет из последовательности не пришел или содержит ошибки, или отправитель может предположить, что пакет не дошел до получателя, если получатель не прислал подтверждение получателю через определенное время.   TCP использует механизм “плавающего окна” (windowing) для регулирования потока пакетов. Windowing уменьшает шанс того, что пакет будет отброшен приемной стороной из-за переполнения буфера.   Заголовок TCP следует сразу за данными прикладного уровня, он содержит поля необходимые для работы механизмов, которые описаны выше, а также определяет порты, которые в свою очередь определяют приложения источника и назначения. Данные с заголовком TCP затем инкапсулируются в заголовок IP.   Структура протокола TCP выглядит следующим образом                                                    TCP Header Structure       Source и Destination порты - 16-битные поля, определяющие приложения источника и назначения для инкапсулированных данных. RFC 1700 определяет все номера для портов (общего и не общего назначения).   Сокет - сочетание порта (источника/назначения) и соответствующего IP-адреса. Сокет уникально определяет каждое приложение в сети.                                                    Source and Destination Ports       Sequence Number - 32-битное поле, определяет где инкапсулированные данные находятся внутри общего потока отправителя. Например, если порядковый номер сегмента 1234 и сегмент содержит 512 байт данных, то следующий сегмент должен иметь порядковый номер 1234 + 512 = 1746   Ниже представлена вырезка из трафика, в котором sequence number равен 337, ожидаемый следующий порядковый номер должен быть 390, который состоить из seq number + TCP Payload (337 + 53 = 390)                                                    Sequence Number 1       А вот вторая вырезка, которая подтверждает ожидаемый в предыдущем пакете порядковый номер.                                                    Sequence Number 2       Acknowledgment Number - 32-битное поле, определяет порядковый номер, который источник ожидает получить от получателя в следующий раз. Если устройство получает номер подтверждения, который не соответствует следующему порядковому номеру, который он собирается отправить (или отправил), то это будет означать, что пакеты были утеряны.   Header Length или еще данное поле называют Data Offset - 4-битное поле, определяющее длину заголовка в 32-битных словах. Данное поле очень важно, т.к. оно позволяет определить начало данных, потому что поле Options имеет переменную длину.                                                    Header Length       Reserved - 4-битное поле, которое всегда заполнено нулями.                                                    Reserved       Flags - 8 однобитовых флагов, которые используются для управления потоком данных и контроля подключения. Флаги слева направо:           CWR - Congestion Window Reduced     ECE - ECN-Echo     URG - Urgent     ACK - Acknowledment     PSH - Push     RST - Reset     SYN - Synchronize     FIN - Final                                                       Flags       Window Size - 16-битное поле, которое используется для контроля потока. Данное поле определяет количество байт, которое отправитель сегмента примет от узла на другом конце соединения, прежде чем этот узел  прекратит передачу, ожидая подтверждения.                                                    Window Size       Window вычисляется путём умножения значения window на window size scaling factor, в случае выше получаем 8181 * 32 = 261792   Checksum - - 16-битное поле, позволяющее обнаружить ошибку в заголовке и инкапсулированных данных.                                                    Checksum       Urgent Pointer - 16-битное поле, используется только в случае использования флага URG. Значение данного поля добавляется к Sequence Number тем самым указывая на окончание срочных данных.                                                    Urgent Pointer       Options - как следует из названия, данное поле определяет опции в процессе TCP. Наиболее часто используемая опция - Maximum Segment Size (MSS), которая информирует получателя о наибольшем размере сегмента, который отправитель готов принять. Оставшаяся часть поля заполняется нулями до выравнивания до значения 4 байт.   Более подробно каждое поле можно рассмотреть, скачав данный дамп   P.S. вся информация представленная здесь используется исключительно в образовательных целях. Все совпадения с реальными объектами, адресами, именами и т.д. случайна и не несёт цели получить от этого выгоду или причинить кому-либо вред.  ","categories": ["networks"],
        "tags": ["protocols","tcp"],
        "url": "/networks/tcp_prot/",
        "teaser": null
      },{
        "title": "Структура протокола UDP",
        "excerpt":"User Datagram Protocol или UDP описан в RFC 768 предоставляет услуги доставки пакетов без подключения с максимальными усилиями. Главное преимущество протокола UDP - отсутствие траты времени на установку соединения с удаленным узлом. Приложения, использующие UDP вместо TCP, понимают это основное преимущество в производительности и поэтому используют именно UDP.   Второе преимущество протокола UDP - размер заголовка, он намного меньше, чем у протокола TCP. Ниже представлена структура заголовка                                                    UDP Header Structure       Поля Source и Destination port идентичны тем, которые есть у протокола TCP, размер данных полей также 16 бит.                                                    Source and Destination Ports       UDP Length - 16-битное поле, указывающее длину всего сегмента в байтах (udp header + udp payload).                                                    Length       Checksum - 16-битное опциональное (необязательно) поле, проверяющее чексумму всего сегмента. Когда поле неиспользуется, то оно заполняется нулями.                                                    Checksum       Полностью изучить протокол можно скачав данный дамп   P.S. вся информация представленная здесь используется исключительно в образовательных целях. Все совпадения с реальными объектами, адресами, именами и т.д. случайна и не несёт цели получить от этого выгоду или причинить кому-либо вред.  ","categories": ["networks"],
        "tags": ["protocols","udp"],
        "url": "/networks/udp_prot/",
        "teaser": null
      },{
        "title": "Протокол IPv6",
        "excerpt":"Протокол IPv6 пришел на замену протоколу IPv4 и хотя в настоящее время IPv4 всё еще везде используется, придет время и протокол IPv6 вытеснит своего предшественника полностью.   Первое, что стоит упомянуть когда рассматривают протокол IPv6 - это измененная структура адреса и количество возможных адресов. Если в IPv4 используется 2^32 адресов, то в новой версии это число достигает невероятных значений 2^128. Структура адреса выглядит следующим образом: 2001:1536:a0b8:3491:c800:00ef:fe74:0c00 - 8 хекстетов, разделенных символом :   Типы адресов IPv6   Всего существует три основных типа IPv6 адресов:      Unicast адреса   Anycast адреса   Multicast адреса   В отличие от IPv4, в IPv6 нет broadcast адресов. Однако, группа multicast адресов “all nodes” делает ту же работу, что и broadcast адреса.   Unicast   IPv6 unicast адреса работают в точности так же как и в IPv4. Данные адреса определяют один интерфейс или устройство. Существует три типа IPv6 unicast адресов:      Global адреса - это те же адреса, что и публичные адреса в IPv4. Они глобально маршрутизируются и могут использоваться при коммуникации через сеть Интернет. В настоящее время вся глобальная одноадресная адресация выделяется из префиксного блока 2000::/3.                                                    Global address structure          Unique local unicast адреса - адреса, которые в IPv4 определены как “серые”, т.е. адреса, описанные в RFC 1918. Данные адреса маршрутизируются в пределах внутренней коммуникации организации и не маршрутизируются в сети Интернет. RFC 4193 определяет блок префиксов fc00::/7 для уникальной локальной одноадресной адресации. Данные адреса всегда начинаются с двоичного значения 1111 110, которое соответствует префиксу fc00::/7. Восьмой бит - бит L в настоящее время установлен в 1, чтобы указать, что адрес назначен локально. Установка бита L на 0 еще не определена и зарезервирована для использования в будущем. Объединение префикса (первых 7 бит) и бита L создает два потенциальных адресных блока:            fc00::/8: зарезервировано для будущего использования       fd00::/8: локальная одноадресная адресация                                                            Unique local address structure          Link-local адреса - немаршрутизируемые адреса, используются для коммуникации в пределах одного непосредственно подключенного канала. Основное назначение данных адресов - обнаружение соседей и определение дубликата адресов. Адреса выделяются из префиксного блока fe80::/10. Данные адреса могут назначаться как вручную, так и динамически с использованием механизма SLAAC (stateless address autoconfiguration). При использовании SLAAC часть Interface ID выводится из MAC-адреса модификацией формата EUI-64.                                                    Link local address structure       Anycast   Anycast адреса представляют скорее сервис нежели чем отдельное устройство, поэтому один адрес может быть назначен разным устройствам, предоставляющим один и тот же сервис. Основное предназначение anycast адресов - обеспечение отказоустойчивости.   На следующей схеме приведён пример того как может выглядеть это в реальности                                                    Anycast       В сети имеется два сервера, которые имеют идентичную адресацию, но физически расположены в разных местах. В зависимости от того где находится клиент, трафик пойдет к ближайшему серверу, опираясь на таблицу маршрутизации.   В случае если в сети произойдет падение одного из маршрутизаторов, находящихся рядом с серверами, произойдет перестроение пути следования трафика для одного из клиентов и трафик для этого клиента пойдет по новому пути. В этом случае оба клиента будут обращаться к одному и тому же серверу.   Какого определённого формата для данных типов адресов не существует, поэтому теоретически любой unicast адрес может быть anycast. Для корректной работы anycast адресов может быть желательно отключать механизм определения дубликата адресов (DAD - Duplicate Address Detection). В операционной системе Cisco IOS и Cisco IOS XE механизм DAD отключается для всего префикса, делается это следующей командой:   1 2 Cisco_CSR1000v(config)# interface gigabitEthernet 1 Cisco_CSR1000v(config-if)# ipv6 address 2001:abcd:1111::1/64 anycast    Для операционной системы Cisco IOS XR механизм DAD отключается для всего интерфейса (включая префиксы link-local) с помощью команды:   1 2 RP/0/0/CPU0:Cisco_XRv(config)# interface gigabitEthernet 0/0/0/0 RP/0/0/CPU0:Cisco_XRv(config-if)# ipv6 nd dad attempts 0   Multicast   Multicast адреса определяют не одно устройство, а группу устройств - multicast группу, при этом в данной группе может состоять как множество устройств, так и одно. Multicast адреса не могут выступать в качестве адреса источника в пакете. В IPv6 не существует как такового broadcast адреса, вместо него есть multicast группа \"All nodes\", которая по сути имеет то же предназначение, что и broadcast в IPv4.   В IPv6 multicast адреса имеют различное назначение: передача информации о протоколе маршрутизации, обнаружение соседних устройств, разрешение IPv6-адресов. Более подробно об этом будет описано в статье по протоколу Neighbor Discovery Protocol                                                    Multicast address structure       Как видно из рисунка выше, первые 8 бит всегда установлены в 1, следующие 4 бита отвечают за флаги. Первые три бита из поля Flags установлены в 0 и в настоящее время не используются. Четвёртый бит из поля Flags - флаг transient.   Флаг T - transient имеет два возможных значения:     0 - постоянный адрес, который широко известен и присваивается IANA   1 - временный адрес, используется для целей тестирования   Поле Scope используется для того, чтобы маршрутизатор мог определить является ли multicast адрес маршрутизируемым. Все диапазоны таких адресов описаны в RFC 4291. Краткая выдержка представлена в таблице ниже.                  Типы диапазонов       IPv6 префикс       Описание                       Reserved       ff00       Зарезервировано                 Interface-Local       ff01       Interface-Local диапазон не позволяет multicast пакетам проходить через интерфейс. Данный диапазон аналогичен адресу unicast loopback, поскольку multicast пакеты содержатся внутри одного устройства.                 Link-Local       ff02       Link-Local диапазон содержит multicast трафик для локальной интерфейсной связи.                 Admin-Local       ff04       Admin-Local диапазон является маршрутизируемым и считается наименьшей административным диапазоном. Граница диапазона действия не имеет определенных ограничений, но обычно трафик ограничен одним отделом или этажом в здании.                 Site-Local       ff05       Site-Local диапазон является также маршрутизируемым и считается большим, чем admin-Local диапазон. Граница обычно ограничивается зданием или регионом.                 Organization-Local       ff08       Organization-Local диапазон является также маршрутизируемым и должен располагаться в одной организации.                 Global       ff0е       Global диапазон не имеет никаких ограничений на достижимость.           Поле Group ID определяет индивидуальную multicast группу. На данное поле отводится 112 бит, 80 из которых в настоящее время не используются и установлены в 0.   Наиболее широко известные и используемые адреса представлены в таблице ниже                  Адрес       Описание                       ff02::1       All nodes адрес                 ff02::2       All-routers адрес                 ff02::5       Aдрес OSPFv3 all routers                 ff02::6       Aдрес OSPFv3 all DR                 ff02::8       IS-IS                 ff02::9       RIPng                 ff02::a       EIGRP                 ff02::d       PIM                 ff02::1:2       Адрес всех DHCPv6 relay агентов и серверов                 ff05::1:3       Адрес всех DHCPv6 серверов                 ff02::1:ffxx:xxxx       Адрес запрашиваемого узла, используется для обнаруженя соседних узлов для разрешения адресов (последние 24 бита [xx:xxxx] адреса сопоставляются с последними 24 битами unicast адреса IPv6)           Более полный список можно увидеть, перейдя по ссылке   Каждое устройство автоматически присоединяется к двум multicast группам: all nodes - ff02::1 и solicited-node - ff02::1:ffxx:xxxx. Группа all nodes используется для связи со всеми интерфейсами на локальном канале, а группа solicited-node требуется для разрешения адресов на уровне канала. Маршрутизаторы также присоединяются к третьей multicast группе all-routers - ff02::2.   Для того чтобы посмотреть в какой группе состоит тот или иной интерфейс необходимо выполнить команду show ipv6 interface &lt;тип интерфейса номер интерфейса&gt;   Cisco IOS   1 2 3 4 5 6 7 8 9 10 11 12 Cisco_CSR1000v# show ipv6 interface gigabitEthernet 1 GigabitEthernet1 is up, line protocol is up   IPv6 is enabled, link-local address is FE80::1    No Virtual link-local address(es):   Global unicast address(es):     2001:ABCD::1, subnet is 2001:ABCD::/64    Joined group address(es):     FF02::1     FF02::2     FF02::1:FF00:1   MTU is 1500 bytes ---часть информации пропущена---   Cisco IOS XR   1 2 3 4 5 6 7 8 9 RP/0/0/CPU0:Cisco_XRv# show ipv6 interface gigabitEthernet 0/0/0/0 Sat Oct 23 16:45:56.754 UTC GigabitEthernet0/0/0/0 is Up, ipv6 protocol is Up, Vrfid is default (0x60000000)   IPv6 is enabled, link-local address is fe80::2    Global unicast address(es):     2001:abcd::2, subnet is 2001:abcd::/64    Joined group address(es): ff02::1:ff00:2 ff02::2 ff02::1   MTU is 1514 (1500 is available to IPv6)   ---часть информации пропущена---   Специальные IPv6 адреса   Помимо основных адресов, описанных выше, есть два типа, которые не включены ни в одну из категорий.      Неопределенный адрес - указывает на то, что на интерфейсе еще нет никакого адреса, обозначается как 0:0:0:0:0:0:0:0 или просто ::. Данный адрес используется устройством когда оно только инициализированно и не получило еще никакого другого адреса   Loopback адрес - используется для того чтобы отправлять пакеты самому себе, обозначается как 0:0:0:0:0:0:0:1 или ::1   Структура заголовка IPv6   Формат заголовка протокола IPv6 представлен на рисунке ниже                                                    Header IPv6       Version - 4-битное поле, также как и в протоколе IPv4 отвечает за версию протокола. Принимает значение 0110.                                                    Version       Traffic Class - 8-битное поле, идентично полю DiffServ в протоколе IPv4.                                                    Traffic Service       Flow Label - 20-битное уникальное для IPv6 поле. Данное поле позволяет помечать определенный поток трафика, при балансировке трафика метка позволяет более точно определять путь, по которому пойдет тот или иной пакет, предотвращая возможное изменение следования порядка пакетов.   Поток определяется как совокупность адреса и порта источника и назначения. Однако, определить порт источника и назначения для маршрутизатора может быть сложной задачей и возможным падением производительности для него. Расширения заголовка IPv6 позволяют маршрутизатору определить заголовок транспортного уровня.                                                    Flow Label       Payload Length - 16-битное поле, определяющее длину содержимого пакета в байтах. Размер заголовка IPv6 всегда фиксирован и составляет 40 байт, поэтому, в отличие от протокола IPv4, вычитать размер заголовка из общего содержимого пакета нет необходимости.                                                    Payload Length       Next Header - 8-битное поле, определяющее заголовок протокола, который следует за протоколом IPv6. Данное поле идентично полю Protocol в заголовке IPv4 и используется для тех же самых целей. Однако, в протоколе IPv6 вместо протокола, располагающегося выше протокола IPv6, можеть быть расширение заголовка IPv6.                                                    Hext Header       Hop Limit - 8-битное поле, выполняющее те же функции, что и поле Time to Live в протоколе IPv4. Если данное поле примет значение 0 на пути следования пакета, то пакет будет отброшен.                                                    Hop Limit       Source и Destination Address - 128-битные поля, определяющие адреса источника и назначения соответственно.              Source и Destination Address       В данном дампе можно более подробно рассмотреть все поля протокола IPv6.   P.S. вся информация представленная здесь используется исключительно в образовательных целях. Все совпадения с реальными объектами, адресами, именами и т.д. случайна и не несёт цели получить от этого выгоду или причинить кому-либо вред.  ","categories": ["networks"],
        "tags": ["protocols","ipv6"],
        "url": "/networks/ipv6_prot/",
        "teaser": null
      }]
